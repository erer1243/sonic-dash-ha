//! A set of functions and types that are used in code generated by the custom macros
//! from `hamgrd_macro`.
use std::{error::Error, fmt::Display, str::FromStr};
use swss_common::{CxxString, FieldValues};

pub trait ToFromFieldValues: Sized {
    fn from_field_values(fvs: &FieldValues) -> Result<Self, FromFieldValuesError>;
    fn to_field_values(&self) -> FieldValues;
}

/// Helper for macro-generated code implementing ToFromFieldValues using ToFromFieldValue on all of a struct's fields.
pub fn parse_field_value<T: ToFromFieldValue>(
    field: &'static str,
    fvs: &FieldValues,
) -> Result<T, FromFieldValuesError> {
    T::from_field_value(fvs.get(field).map(|s| s.as_bytes())).map_err(|error| FromFieldValuesError { field, error })
}

/// Error that occurred in `ToFromFieldValues::from_field_values`
#[derive(Debug)]
pub struct FromFieldValuesError {
    field: &'static str,
    error: FromFieldValueError,
}

impl Display for FromFieldValuesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "Parsing field '{}': {}", self.field, self.error)
    }
}

impl Error for FromFieldValuesError {}

/// Convert a single value to/from an swss field value (`CxxString`/`Option<CxxString>`)
pub trait ToFromFieldValue: Sized {
    fn to_field_value(&self) -> CxxString;

    /// This takes an Option to represent that a field may not be present in a `FieldValues` map.
    fn from_field_value(value: Option<&[u8]>) -> Result<Self, FromFieldValueError>;
}

/// An error that occurred in `ToFromFieldValue::from_field_value`.
#[derive(Debug)]
pub enum FromFieldValueError {
    Missing,
    Invalid { data: String, error: Box<dyn Error> },
}

impl Display for FromFieldValueError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            FromFieldValueError::Missing => write!(f, "no value was provided, but one is needed"),
            FromFieldValueError::Invalid { data, error } => write!(f, "invalid value '{data}': {error}"),
        }
    }
}

impl Error for FromFieldValueError {}

/// Macro for implementing ToFromFieldValue for types that implement ToString + FromStr (i.e. primitives/basic std types)
macro_rules! impl_tofromfieldvalue_using_tostring_fromstr {
    ($($t:ty)*) => {
        $(
          impl ToFromFieldValue for $t {
              fn to_field_value(&self) -> CxxString {
                  self.to_string().into()
              }

              fn from_field_value(val: Option<&[u8]>) -> Result<Self, FromFieldValueError> {
                  let Some(bytes) = val else { return Err(FromFieldValueError::Missing) };
                  let rs_str = String::from_utf8_lossy(bytes);
                  <$t>::from_str(&rs_str).map_err(|e| FromFieldValueError::Invalid {
                      data: rs_str.into_owned(),
                      error: Box::new(e),
                  })
              }
          }
        )*
    }
}

impl_tofromfieldvalue_using_tostring_fromstr! { u8 u16 u32 u64 u128 i8 i16 i32 i64 i128 String bool }

impl<T: ToFromFieldValue> ToFromFieldValue for Option<T> {
    fn to_field_value(&self) -> CxxString {
        match self {
            Some(val) => val.to_field_value(),
            None => CxxString::new("none"),
        }
    }

    fn from_field_value(value: Option<&[u8]>) -> Result<Self, FromFieldValueError> {
        match value {
            Some(bytes) => {
                if bytes.is_empty() || bytes == b"none" {
                    Ok(None)
                } else {
                    Ok(Some(T::from_field_value(value)?))
                }
            }
            None => Ok(None),
        }
    }
}

impl<T: ToFromFieldValue> ToFromFieldValue for Vec<T> {
    fn to_field_value(&self) -> CxxString {
        let mut bytes = Vec::new();
        for val in self {
            bytes.extend_from_slice(val.to_field_value().as_bytes());
            bytes.push(b',');
        }
        if !bytes.is_empty() {
            bytes.pop();
        }
        bytes.into()
    }

    fn from_field_value(value: Option<&[u8]>) -> Result<Self, FromFieldValueError> {
        let Some(bytes) = value else {
            return Err(FromFieldValueError::Missing);
        };
        bytes
            .split(|c| *c == b',')
            .map(|s| T::from_field_value(Some(s)))
            .collect()
    }
}

/// Error used in derived implementations of `from_field_value` on enums.
#[derive(Debug)]
pub struct InvalidVariantError {
    pub valid_variants: &'static [&'static str],
}

impl Display for InvalidVariantError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "valid values are: {}", self.valid_variants.join(", "))
    }
}

impl Error for InvalidVariantError {}
